{
    name: "fork.c",
    path: "/fork.c",
    body: "/*\n *  linux/kernel/fork.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n */\n\n/*\n *  'fork.c' contains the help-routines for the 'fork' system call\n * (see also entry.S and others).\n * Fork is rather simple, once you get the hang of it, but the memory\n * management can be a bitch. See 'mm/memory.c': 'copy_page_range()'\n */\n\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/unistd.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/completion.h>\n#include <linux/personality.h>\n#include <linux/mempolicy.h>\n#include <linux/sem.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/iocontext.h>\n#include <linux/key.h>\n#include <linux/binfmts.h>\n#include <linux/mman.h>\n#include <linux/mmu_notifier.h>\n#include <linux/fs.h>\n#include <linux/nsproxy.h>\n#include <linux/capability.h>\n#include <linux/cpu.h>\n#include <linux/cgroup.h>\n#include <linux/security.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/syscalls.h>\n#include <linux/jiffies.h>\n#include <linux/futex.h>\n#include <linux/compat.h>\n#include <linux/kthread.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/rcupdate.h>\n#include <linux/ptrace.h>\n#include <linux/mount.h>\n#include <linux/audit.h>\n#include <linux/memcontrol.h>\n#include <linux/ftrace.h>\n#include <linux/proc_fs.h>\n#include <linux/profile.h>\n#include <linux/rmap.h>\n#include <linux/ksm.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/cn_proc.h>\n#include <linux/freezer.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/random.h>\n#include <linux/tty.h>\n#include <linux/blkdev.h>\n#include <linux/fs_struct.h>\n#include <linux/magic.h>\n#include <linux/perf_event.h>\n#include <linux/posix-timers.h>\n#include <linux/user-return-notifier.h>\n#include <linux/oom.h>\n#include <linux/khugepaged.h>\n#include <linux/signalfd.h>\n\n#include <asm/pgtable.h>\n#include <asm/pgalloc.h>\n#include <asm/uaccess.h>\n#include <asm/mmu_context.h>\n#include <asm/cacheflush.h>\n#include <asm/tlbflush.h>\n\n#include <trace/events/sched.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/task.h>\n\n/*\n * Protected counters by write_lock_irq(&tasklist_lock)\n */\nunsigned long total_forks; /* Handle normal Linux uptimes. */\nint nr_threads;         /* The idle threads do not count.. */\n\nint max_threads;       /* tunable limit on nr_threads */\n\nDEFINE_PER_CPU(unsigned long, process_counts) = 0;\n\n__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);  /* outer */\n\n#ifdef CONFIG_PROVE_RCU\nint lockdep_tasklist_lock_is_held(void)\n{\n  return lockdep_is_held(&tasklist_lock);\n}\nEXPORT_SYMBOL_GPL(lockdep_tasklist_lock_is_held);\n#endif /* #ifdef CONFIG_PROVE_RCU */\n\nint nr_processes(void)\n{\n  int cpu;\n  int total = 0;\n\n  for_each_possible_cpu(cpu)\n        total += per_cpu(process_counts, cpu);\n\n  return total;\n}\n\n#ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR\n# define alloc_task_struct_node(node)        \\\n        kmem_cache_alloc_node(task_struct_cachep, GFP_KERNEL, node)\n# define free_task_struct(tsk)         \\\n        kmem_cache_free(task_struct_cachep, (tsk))\nstatic struct kmem_cache *task_struct_cachep;\n#endif\n\n#ifndef __HAVE_ARCH_THREAD_INFO_ALLOCATOR\nstatic struct thread_info *alloc_thread_info_node(struct task_struct *tsk,\n                          int node)\n{\n#ifdef CONFIG_DEBUG_STACK_USAGE\n   gfp_t mask = GFP_KERNEL | __GFP_ZERO;\n#else\n  gfp_t mask = GFP_KERNEL;\n#endif\n  struct page *page = alloc_pages_node(node, mask, THREAD_SIZE_ORDER);\n\n    return page ? page_address(page) : NULL;\n}\n\nstatic inline void free_thread_info(struct thread_info *ti)\n{\n free_pages((unsigned long)ti, THREAD_SIZE_ORDER);\n}\n#endif\n\n/* SLAB cache for signal_struct structures (tsk->signal) */\nstatic struct kmem_cache *signal_cachep;\n\n/* SLAB cache for sighand_struct structures (tsk->sighand) */\nstruct kmem_cache *sighand_cachep;\n\n/* SLAB cache for files_struct structures (tsk->files) */\nstruct kmem_cache *files_cachep;\n\n/* SLAB cache for fs_struct structures (tsk->fs) */\nstruct kmem_cache *fs_cachep;\n\n/* SLAB cache for vm_area_struct structures */\nstruct kmem_cache *vm_area_cachep;\n\n/* SLAB cache for mm_struct structures (tsk->mm) */\nstatic struct kmem_cache *mm_cachep;\n\nstatic void account_kernel_stack(struct thread_info *ti, int account)\n{\n    struct zone *zone = page_zone(virt_to_page(ti));\n\n    mod_zone_page_state(zone, NR_KERNEL_STACK, account);\n}\n\nvoid free_task(struct task_struct *tsk)\n{\n account_kernel_stack(tsk->stack, -1);\n free_thread_info(tsk->stack);\n rt_mutex_debug_task_free(tsk);\n    ftrace_graph_exit_task(tsk);\n  free_task_struct(tsk);\n}\nEXPORT_SYMBOL(free_task);\n\nstatic inline void free_signal_struct(struct signal_struct *sig)\n{\n   taskstats_tgid_free(sig);\n sched_autogroup_exit(sig);\n    kmem_cache_free(signal_cachep, sig);\n}\n\nstatic inline void put_signal_struct(struct signal_struct *sig)\n{\n if (atomic_dec_and_test(&sig->sigcnt))\n        free_signal_struct(sig);\n}\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n WARN_ON(!tsk->exit_state);\n    WARN_ON(atomic_read(&tsk->usage));\n    WARN_ON(tsk == current);\n\n    security_task_free(tsk);\n  exit_creds(tsk);\n  delayacct_tsk_free(tsk);\n  put_signal_struct(tsk->signal);\n\n if (!profile_handoff_task(tsk))\n       free_task(tsk);\n}\nEXPORT_SYMBOL_GPL(__put_task_struct);\n\n/*\n * macro override instead of weak attribute alias, to workaround\n * gcc 4.1.0 and 4.1.1 bugs with weak attribute and empty functions.\n */\n#ifndef arch_task_cache_init\n#define arch_task_cache_init()\n#endif\n\nvoid __init fork_init(unsigned long mempages)\n{\n#ifndef __HAVE_ARCH_TASK_STRUCT_ALLOCATOR\n#ifndef ARCH_MIN_TASKALIGN\n#define ARCH_MIN_TASKALIGN   L1_CACHE_BYTES\n#endif\n    /* create a slab on which task_structs can be allocated */\n    task_struct_cachep =\n      kmem_cache_create(\"task_struct\", sizeof(struct task_struct),\n            ARCH_MIN_TASKALIGN, SLAB_PANIC | SLAB_NOTRACK, NULL);\n#endif\n\n   /* do the arch specific task caches init */\n   arch_task_cache_init();\n\n /*\n     * The default maximum number of threads is set to a safe\n  * value: the thread structures can take up at most half\n   * of memory.\n  */\n   max_threads = mempages / (8 * THREAD_SIZE / PAGE_SIZE);\n\n /*\n     * we need to allow at least 20 threads to boot a system\n   */\n   if (max_threads < 20)\n     max_threads = 20;\n\n   init_task.signal->rlim[RLIMIT_NPROC].rlim_cur = max_threads/2;\n    init_task.signal->rlim[RLIMIT_NPROC].rlim_max = max_threads/2;\n    init_task.signal->rlim[RLIMIT_SIGPENDING] =\n       init_task.signal->rlim[RLIMIT_NPROC];\n}\n\nint __attribute__((weak)) arch_dup_task_struct(struct task_struct *dst,\n                          struct task_struct *src)\n{\n    *dst = *src;\n  return 0;\n}\n\nstatic struct task_struct *dup_task_struct(struct task_struct *orig)\n{\n   struct task_struct *tsk;\n  struct thread_info *ti;\n   unsigned long *stackend;\n  int node = tsk_fork_get_node(orig);\n   int err;\n\n    prepare_to_copy(orig);\n\n  tsk = alloc_task_struct_node(node);\n   if (!tsk)\n     return NULL;\n\n    ti = alloc_thread_info_node(tsk, node);\n   if (!ti) {\n        free_task_struct(tsk);\n        return NULL;\n  }\n\n   err = arch_dup_task_struct(tsk, orig);\n    if (err)\n      goto out;\n\n   tsk->stack = ti;\n\n    setup_thread_stack(tsk, orig);\n    clear_user_return_notifier(tsk);\n  clear_tsk_need_resched(tsk);\n  stackend = end_of_stack(tsk);\n *stackend = STACK_END_MAGIC;    /* for overflow detection */\n\n#ifdef CONFIG_CC_STACKPROTECTOR\n   tsk->stack_canary = get_random_int();\n#endif\n\n   /*\n     * One for us, one for whoever does the \"release_task()\" (usually\n    * parent)\n     */\n   atomic_set(&tsk->usage, 2);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n   tsk->btrace_seq = 0;\n#endif\n  tsk->splice_pipe = NULL;\n\n    account_kernel_stack(ti, 1);\n\n    return tsk;\n\nout:\n   free_thread_info(ti);\n free_task_struct(tsk);\n    return NULL;\n}\n\n#ifdef CONFIG_MMU\nstatic int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)\n{\n   struct vm_area_struct *mpnt, *tmp, *prev, **pprev;\n    struct rb_node **rb_link, *rb_parent;\n int retval;\n   unsigned long charge;\n struct mempolicy *pol;\n\n  down_write(&oldmm->mmap_sem);\n flush_cache_dup_mm(oldmm);\n    /*\n     * Not linked in yet - no deadlock potential:\n  */\n   down_write_nested(&mm->mmap_sem, SINGLE_DEPTH_NESTING);\n\n mm->locked_vm = 0;\n    mm->mmap = NULL;\n  mm->mmap_cache = NULL;\n    mm->free_area_cache = oldmm->mmap_base;\n   mm->cached_hole_size = ~0UL;\n  mm->map_count = 0;\n    cpumask_clear(mm_cpumask(mm));\n    mm->mm_rb = RB_ROOT;\n  rb_link = &mm->mm_rb.rb_node;\n rb_parent = NULL;\n pprev = &mm->mmap;\n    retval = ksm_fork(mm, oldmm);\n if (retval)\n       goto out;\n retval = khugepaged_fork(mm, oldmm);\n  if (retval)\n       goto out;\n\n   prev = NULL;\n  for (mpnt = oldmm->mmap; mpnt; mpnt = mpnt->vm_next) {\n        struct file *file;\n\n      if (mpnt->vm_flags & VM_DONTCOPY) {\n           long pages = vma_pages(mpnt);\n         mm->total_vm -= pages;\n            vm_stat_account(mm, mpnt->vm_flags, mpnt->vm_file,\n                                -pages);\n          continue;\n     }\n     charge = 0;\n       if (mpnt->vm_flags & VM_ACCOUNT) {\n            unsigned long len;\n            len = (mpnt->vm_end - mpnt->vm_start) >> PAGE_SHIFT;\n          if (security_vm_enough_memory_mm(oldmm, len)) /* sic */\n               goto fail_nomem;\n          charge = len;\n     }\n     tmp = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);\n       if (!tmp)\n         goto fail_nomem;\n      *tmp = *mpnt;\n     INIT_LIST_HEAD(&tmp->anon_vma_chain);\n     pol = mpol_dup(vma_policy(mpnt));\n     retval = PTR_ERR(pol);\n        if (IS_ERR(pol))\n          goto fail_nomem_policy;\n       vma_set_policy(tmp, pol);\n     tmp->vm_mm = mm;\n      if (anon_vma_fork(tmp, mpnt))\n         goto fail_nomem_anon_vma_fork;\n        tmp->vm_flags &= ~VM_LOCKED;\n      tmp->vm_next = tmp->vm_prev = NULL;\n       file = tmp->vm_file;\n      if (file) {\n           struct inode *inode = file->f_path.dentry->d_inode;\n           struct address_space *mapping = file->f_mapping;\n\n            get_file(file);\n           if (tmp->vm_flags & VM_DENYWRITE)\n             atomic_dec(&inode->i_writecount);\n         mutex_lock(&mapping->i_mmap_mutex);\n           if (tmp->vm_flags & VM_SHARED)\n                mapping->i_mmap_writable++;\n           flush_dcache_mmap_lock(mapping);\n          /* insert tmp into the share list, just after mpnt */\n         vma_prio_tree_add(tmp, mpnt);\n         flush_dcache_mmap_unlock(mapping);\n            mutex_unlock(&mapping->i_mmap_mutex);\n     }\n\n       /*\n         * Clear hugetlb-related page reserves for children. This only\n         * affects MAP_PRIVATE mappings. Faults generated by the child\n         * are not guaranteed to succeed, even if read-only\n        */\n       if (is_vm_hugetlb_page(tmp))\n          reset_vma_resv_huge_pages(tmp);\n\n     /*\n         * Link in the new vma and copy the page table entries.\n        */\n       *pprev = tmp;\n     pprev = &tmp->vm_next;\n        tmp->vm_prev = prev;\n      prev = tmp;\n\n     __vma_link_rb(mm, tmp, rb_link, rb_parent);\n       rb_link = &tmp->vm_rb.rb_right;\n       rb_parent = &tmp->vm_rb;\n\n        mm->map_count++;\n      retval = copy_page_range(mm, oldmm, mpnt);\n\n      if (tmp->vm_ops && tmp->vm_ops->open)\n         tmp->vm_ops->open(tmp);\n\n     if (retval)\n           goto out;\n }\n /* a new mm has just been created */\n  arch_dup_mmap(oldmm, mm);\n retval = 0;\nout:\n up_write(&mm->mmap_sem);\n  flush_tlb_mm(oldmm);\n  up_write(&oldmm->mmap_sem);\n   return retval;\nfail_nomem_anon_vma_fork:\n mpol_put(pol);\nfail_nomem_policy:\n    kmem_cache_free(vm_area_cachep, tmp);\nfail_nomem:\n    retval = -ENOMEM;\n vm_unacct_memory(charge);\n goto out;\n}\n\nstatic inline int mm_alloc_pgd(struct mm_struct *mm)\n{\n   mm->pgd = pgd_alloc(mm);\n  if (unlikely(!mm->pgd))\n       return -ENOMEM;\n   return 0;\n}\n\nstatic inline void mm_free_pgd(struct mm_struct *mm)\n{\n   pgd_free(mm, mm->pgd);\n}\n#else\n#define dup_mmap(mm, oldmm)   (0)\n#define mm_alloc_pgd(mm)   (0)\n#define mm_free_pgd(mm)\n#endif /* CONFIG_MMU */\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(mmlist_lock);\n\n#define allocate_mm()  (kmem_cache_alloc(mm_cachep, GFP_KERNEL))\n#define free_mm(mm)  (kmem_cache_free(mm_cachep, (mm)))\n\nstatic unsigned long default_dump_filter = MMF_DUMP_FILTER_DEFAULT;\n\nstatic int __init coredump_filter_setup(char *s)\n{\n  default_dump_filter =\n     (simple_strtoul(s, NULL, 0) << MMF_DUMP_FILTER_SHIFT) &\n       MMF_DUMP_FILTER_MASK;\n return 1;\n}\n\n__setup(\"coredump_filter=\", coredump_filter_setup);\n\n#include <linux/init_task.h>\n\nstatic void mm_init_aio(struct mm_struct *mm)\n{\n#ifdef CONFIG_AIO\n  spin_lock_init(&mm->ioctx_lock);\n  INIT_HLIST_HEAD(&mm->ioctx_list);\n#endif\n}\n\nstatic struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p)\n{\n  atomic_set(&mm->mm_users, 1);\n atomic_set(&mm->mm_count, 1);\n init_rwsem(&mm->mmap_sem);\n    INIT_LIST_HEAD(&mm->mmlist);\n  mm->flags = (current->mm) ?\n       (current->mm->flags & MMF_INIT_MASK) : default_dump_filter;\n   mm->core_state = NULL;\n    mm->nr_ptes = 0;\n  memset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n   spin_lock_init(&mm->page_table_lock);\n mm->free_area_cache = TASK_UNMAPPED_BASE;\n mm->cached_hole_size = ~0UL;\n  mm_init_aio(mm);\n  mm_init_owner(mm, p);\n\n   if (likely(!mm_alloc_pgd(mm))) {\n      mm->def_flags = 0;\n        mmu_notifier_mm_init(mm);\n     return mm;\n    }\n\n   free_mm(mm);\n  return NULL;\n}\n\nstatic void check_mm(struct mm_struct *mm)\n{\n  int i;\n\n  for (i = 0; i < NR_MM_COUNTERS; i++) {\n        long x = atomic_long_read(&mm->rss_stat.count[i]);\n\n      if (unlikely(x))\n          printk(KERN_ALERT \"BUG: Bad rss-counter state \"\n                   \"mm:%p idx:%d val:%ld\\n\", mm, i, x);\n }\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n   VM_BUG_ON(mm->pmd_huge_pte);\n#endif\n}\n\n/*\n * Allocate and initialize an mm_struct.\n */\nstruct mm_struct *mm_alloc(void)\n{\n struct mm_struct *mm;\n\n   mm = allocate_mm();\n   if (!mm)\n      return NULL;\n\n    memset(mm, 0, sizeof(*mm));\n   mm_init_cpumask(mm);\n  return mm_init(mm, current);\n}\n\n/*\n * Called when the last reference to the mm\n * is dropped: either by a lazy thread or by\n * mmput. Free the page directory and the mm.\n */\nvoid __mmdrop(struct mm_struct *mm)\n{\n  BUG_ON(mm == &init_mm);\n   mm_free_pgd(mm);\n  destroy_context(mm);\n  mmu_notifier_mm_destroy(mm);\n  check_mm(mm);\n free_mm(mm);\n}\nEXPORT_SYMBOL_GPL(__mmdrop);\n\n/*\n * Decrement the use count and release all resources for an mm.\n */\nvoid mmput(struct mm_struct *mm)\n{\n    might_sleep();\n\n  if (atomic_dec_and_test(&mm->mm_users)) {\n     exit_aio(mm);\n     ksm_exit(mm);\n     khugepaged_exit(mm); /* must run before exit_mmap */\n      exit_mmap(mm);\n        set_mm_exe_file(mm, NULL);\n        if (!list_empty(&mm->mmlist)) {\n           spin_lock(&mmlist_lock);\n          list_del(&mm->mmlist);\n            spin_unlock(&mmlist_lock);\n        }\n     put_swap_token(mm);\n       if (mm->binfmt)\n           module_put(mm->binfmt->module);\n       mmdrop(mm);\n   }\n}\nEXPORT_SYMBOL_GPL(mmput);\n\n/*\n * We added or removed a vma mapping the executable. The vmas are only mapped\n * during exec and are not mapped with the mmap system call.\n * Callers must hold down_write() on the mm's mmap_sem for these\n */\nvoid added_exe_file_vma(struct mm_struct *mm)\n{\n   mm->num_exe_file_vmas++;\n}\n\nvoid removed_exe_file_vma(struct mm_struct *mm)\n{\n mm->num_exe_file_vmas--;\n  if ((mm->num_exe_file_vmas == 0) && mm->exe_file) {\n       fput(mm->exe_file);\n       mm->exe_file = NULL;\n  }\n\n}\n\nvoid set_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file)\n{\n    if (new_exe_file)\n     get_file(new_exe_file);\n   if (mm->exe_file)\n     fput(mm->exe_file);\n   mm->exe_file = new_exe_file;\n  mm->num_exe_file_vmas = 0;\n}\n\nstruct file *get_mm_exe_file(struct mm_struct *mm)\n{\n    struct file *exe_file;\n\n  /* We need mmap_sem to protect against races with removal of\n   * VM_EXECUTABLE vmas */\n  down_read(&mm->mmap_sem);\n exe_file = mm->exe_file;\n  if (exe_file)\n     get_file(exe_file);\n   up_read(&mm->mmap_sem);\n   return exe_file;\n}\n\nstatic void dup_mm_exe_file(struct mm_struct *oldmm, struct mm_struct *newmm)\n{\n   /* It's safe to write the exe_file pointer without exe_file_lock because\n   * this is called during fork when the task is not yet in /proc */\n    newmm->exe_file = get_mm_exe_file(oldmm);\n}\n\n/**\n * get_task_mm - acquire a reference to the task's mm\n *\n * Returns %NULL if the task has no mm.  Checks PF_KTHREAD (meaning\n * this kernel workthread has transiently adopted a user mm with use_mm,\n * to do its AIO) is not set and if so returns a reference to it, after\n * bumping up the use count.  User must release the mm via mmput()\n * after use.  Typically used by /proc and ptrace.\n */\nstruct mm_struct *get_task_mm(struct task_struct *task)\n{\n   struct mm_struct *mm;\n\n   task_lock(task);\n  mm = task->mm;\n    if (mm) {\n     if (task->flags & PF_KTHREAD)\n         mm = NULL;\n        else\n          atomic_inc(&mm->mm_users);\n    }\n task_unlock(task);\n    return mm;\n}\nEXPORT_SYMBOL_GPL(get_task_mm);\n\nstruct mm_struct *mm_access(struct task_struct *task, unsigned int mode)\n{\n struct mm_struct *mm;\n int err;\n\n    err =  mutex_lock_killable(&task->signal->cred_guard_mutex);\n  if (err)\n      return ERR_PTR(err);\n\n    mm = get_task_mm(task);\n   if (mm && mm != current->mm &&\n            !ptrace_may_access(task, mode)) {\n     mmput(mm);\n        mm = ERR_PTR(-EACCES);\n    }\n mutex_unlock(&task->signal->cred_guard_mutex);\n\n  return mm;\n}\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n  struct completion *vfork;\n\n   task_lock(tsk);\n   vfork = tsk->vfork_done;\n  if (likely(vfork)) {\n      tsk->vfork_done = NULL;\n       complete(vfork);\n  }\n task_unlock(tsk);\n}\n\nstatic int wait_for_vfork_done(struct task_struct *child,\n             struct completion *vfork)\n{\n  int killed;\n\n freezer_do_not_count();\n   killed = wait_for_completion_killable(vfork);\n freezer_count();\n\n    if (killed) {\n     task_lock(child);\n     child->vfork_done = NULL;\n     task_unlock(child);\n   }\n\n   put_task_struct(child);\n   return killed;\n}\n\n/* Please note the differences between mmput and mm_release.\n * mmput is called whenever we stop holding onto a mm_struct,\n * error success whatever.\n *\n * mm_release is called after a mm_struct has been removed\n * from the current process.\n *\n * This difference is important for error handling, when we\n * only half set up a mm_struct for a new process and need to restore\n * the old one.  Because we mmput the new mm_struct before\n * restoring the old one. . .\n * Eric Biederman 10 January 1998\n */\nvoid mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n  /* Get rid of any futexes when releasing the mm */\n#ifdef CONFIG_FUTEX\n   if (unlikely(tsk->robust_list)) {\n     exit_robust_list(tsk);\n        tsk->robust_list = NULL;\n  }\n#ifdef CONFIG_COMPAT\n   if (unlikely(tsk->compat_robust_list)) {\n      compat_exit_robust_list(tsk);\n     tsk->compat_robust_list = NULL;\n   }\n#endif\n if (unlikely(!list_empty(&tsk->pi_state_list)))\n       exit_pi_state_list(tsk);\n#endif\n\n    /* Get rid of any cached register state */\n    deactivate_mm(tsk, mm);\n\n if (tsk->vfork_done)\n      complete_vfork_done(tsk);\n\n   /*\n     * If we're exiting normally, clear a user-space tid field if\n  * requested.  We leave this alone when dying by signal, to leave\n  * the value intact in a core dump, and to save the unnecessary\n    * trouble, say, a killed vfork parent shouldn't touch this mm.\n    * Userland only wants this done for a sys_exit.\n   */\n   if (tsk->clear_child_tid) {\n       if (!(tsk->flags & PF_SIGNALED) &&\n            atomic_read(&mm->mm_users) > 1) {\n         /*\n             * We don't check the error code - if userspace has\n            * not set up a proper pointer then tough luck.\n            */\n           put_user(0, tsk->clear_child_tid);\n            sys_futex(tsk->clear_child_tid, FUTEX_WAKE,\n                   1, NULL, NULL, 0);\n        }\n     tsk->clear_child_tid = NULL;\n  }\n}\n\n/*\n * Allocate a new mm structure and copy contents from the\n * mm structure of the passed in task structure.\n */\nstruct mm_struct *dup_mm(struct task_struct *tsk)\n{\n    struct mm_struct *mm, *oldmm = current->mm;\n   int err;\n\n    if (!oldmm)\n       return NULL;\n\n    mm = allocate_mm();\n   if (!mm)\n      goto fail_nomem;\n\n    memcpy(mm, oldmm, sizeof(*mm));\n   mm_init_cpumask(mm);\n\n    /* Initializing for Swap token stuff */\n   mm->token_priority = 0;\n   mm->last_interval = 0;\n\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n  mm->pmd_huge_pte = NULL;\n#endif\n\n    if (!mm_init(mm, tsk))\n        goto fail_nomem;\n\n    if (init_new_context(tsk, mm))\n        goto fail_nocontext;\n\n    dup_mm_exe_file(oldmm, mm);\n\n err = dup_mmap(mm, oldmm);\n    if (err)\n      goto free_pt;\n\n   mm->hiwater_rss = get_mm_rss(mm);\n mm->hiwater_vm = mm->total_vm;\n\n  if (mm->binfmt && !try_module_get(mm->binfmt->module))\n        goto free_pt;\n\n   return mm;\n\nfree_pt:\n    /* don't put binfmt in mmput, we haven't got module yet */\n    mm->binfmt = NULL;\n    mmput(mm);\n\nfail_nomem:\n return NULL;\n\nfail_nocontext:\n   /*\n     * If init_new_context() failed, we cannot use mmput() to free the mm\n  * because it calls destroy_context()\n  */\n   mm_free_pgd(mm);\n  free_mm(mm);\n  return NULL;\n}\n\nstatic int copy_mm(unsigned long clone_flags, struct task_struct *tsk)\n{\n  struct mm_struct *mm, *oldmm;\n int retval;\n\n tsk->min_flt = tsk->maj_flt = 0;\n  tsk->nvcsw = tsk->nivcsw = 0;\n#ifdef CONFIG_DETECT_HUNG_TASK\n tsk->last_switch_count = tsk->nvcsw + tsk->nivcsw;\n#endif\n\n  tsk->mm = NULL;\n   tsk->active_mm = NULL;\n\n  /*\n     * Are we cloning a kernel thread?\n     *\n     * We need to steal a active VM for that..\n     */\n   oldmm = current->mm;\n  if (!oldmm)\n       return 0;\n\n   if (clone_flags & CLONE_VM) {\n     atomic_inc(&oldmm->mm_users);\n     mm = oldmm;\n       goto good_mm;\n }\n\n   retval = -ENOMEM;\n mm = dup_mm(tsk);\n if (!mm)\n      goto fail_nomem;\n\ngood_mm:\n  /* Initializing for Swap token stuff */\n   mm->token_priority = 0;\n   mm->last_interval = 0;\n\n  tsk->mm = mm;\n tsk->active_mm = mm;\n  return 0;\n\nfail_nomem:\n  return retval;\n}\n\nstatic int copy_fs(unsigned long clone_flags, struct task_struct *tsk)\n{\n    struct fs_struct *fs = current->fs;\n   if (clone_flags & CLONE_FS) {\n     /* tsk->fs is already what we want */\n     spin_lock(&fs->lock);\n     if (fs->in_exec) {\n            spin_unlock(&fs->lock);\n           return -EAGAIN;\n       }\n     fs->users++;\n      spin_unlock(&fs->lock);\n       return 0;\n }\n tsk->fs = copy_fs_struct(fs);\n if (!tsk->fs)\n     return -ENOMEM;\n   return 0;\n}\n\nstatic int copy_files(unsigned long clone_flags, struct task_struct *tsk)\n{\n  struct files_struct *oldf, *newf;\n int error = 0;\n\n  /*\n     * A background process may not have any files ...\n     */\n   oldf = current->files;\n    if (!oldf)\n        goto out;\n\n   if (clone_flags & CLONE_FILES) {\n      atomic_inc(&oldf->count);\n     goto out;\n }\n\n   newf = dup_fd(oldf, &error);\n  if (!newf)\n        goto out;\n\n   tsk->files = newf;\n    error = 0;\nout:\n  return error;\n}\n\nstatic int copy_io(unsigned long clone_flags, struct task_struct *tsk)\n{\n#ifdef CONFIG_BLOCK\n    struct io_context *ioc = current->io_context;\n struct io_context *new_ioc;\n\n if (!ioc)\n     return 0;\n /*\n     * Share io context with parent, if CLONE_IO is set\n    */\n   if (clone_flags & CLONE_IO) {\n     tsk->io_context = ioc_task_link(ioc);\n     if (unlikely(!tsk->io_context))\n           return -ENOMEM;\n   } else if (ioprio_valid(ioc->ioprio)) {\n       new_ioc = get_task_io_context(tsk, GFP_KERNEL, NUMA_NO_NODE);\n     if (unlikely(!new_ioc))\n           return -ENOMEM;\n\n     new_ioc->ioprio = ioc->ioprio;\n        put_io_context(new_ioc);\n  }\n#endif\n return 0;\n}\n\nstatic int copy_sighand(unsigned long clone_flags, struct task_struct *tsk)\n{\n    struct sighand_struct *sig;\n\n if (clone_flags & CLONE_SIGHAND) {\n        atomic_inc(&current->sighand->count);\n     return 0;\n }\n sig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n   rcu_assign_pointer(tsk->sighand, sig);\n    if (!sig)\n     return -ENOMEM;\n   atomic_set(&sig->count, 1);\n   memcpy(sig->action, current->sighand->action, sizeof(sig->action));\n   return 0;\n}\n\nvoid __cleanup_sighand(struct sighand_struct *sighand)\n{\n if (atomic_dec_and_test(&sighand->count)) {\n       signalfd_cleanup(sighand);\n        kmem_cache_free(sighand_cachep, sighand);\n }\n}\n\n\n/*\n * Initialize POSIX timer handling for a thread group.\n */\nstatic void posix_cpu_timers_init_group(struct signal_struct *sig)\n{\n  unsigned long cpu_limit;\n\n    /* Thread group counters. */\n  thread_group_cputime_init(sig);\n\n cpu_limit = ACCESS_ONCE(sig->rlim[RLIMIT_CPU].rlim_cur);\n  if (cpu_limit != RLIM_INFINITY) {\n     sig->cputime_expires.prof_exp = secs_to_cputime(cpu_limit);\n       sig->cputimer.running = 1;\n    }\n\n   /* The timer lists. */\n    INIT_LIST_HEAD(&sig->cpu_timers[0]);\n  INIT_LIST_HEAD(&sig->cpu_timers[1]);\n  INIT_LIST_HEAD(&sig->cpu_timers[2]);\n}\n\nstatic int copy_signal(unsigned long clone_flags, struct task_struct *tsk)\n{\n  struct signal_struct *sig;\n\n  if (clone_flags & CLONE_THREAD)\n       return 0;\n\n   sig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);\n   tsk->signal = sig;\n    if (!sig)\n     return -ENOMEM;\n\n sig->nr_threads = 1;\n  atomic_set(&sig->live, 1);\n    atomic_set(&sig->sigcnt, 1);\n  init_waitqueue_head(&sig->wait_chldexit);\n if (clone_flags & CLONE_NEWPID)\n       sig->flags |= SIGNAL_UNKILLABLE;\n  sig->curr_target = tsk;\n   init_sigpending(&sig->shared_pending);\n    INIT_LIST_HEAD(&sig->posix_timers);\n\n hrtimer_init(&sig->real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n    sig->real_timer.function = it_real_fn;\n\n  task_lock(current->group_leader);\n memcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);\n   task_unlock(current->group_leader);\n\n posix_cpu_timers_init_group(sig);\n\n   tty_audit_fork(sig);\n  sched_autogroup_fork(sig);\n\n#ifdef CONFIG_CGROUPS\n   init_rwsem(&sig->group_rwsem);\n#endif\n\n  sig->oom_adj = current->signal->oom_adj;\n  sig->oom_score_adj = current->signal->oom_score_adj;\n  sig->oom_score_adj_min = current->signal->oom_score_adj_min;\n\n    sig->has_child_subreaper = current->signal->has_child_subreaper ||\n                   current->signal->is_child_subreaper;\n\n mutex_init(&sig->cred_guard_mutex);\n\n return 0;\n}\n\nstatic void copy_flags(unsigned long clone_flags, struct task_struct *p)\n{\n   unsigned long new_flags = p->flags;\n\n new_flags &= ~(PF_SUPERPRIV | PF_WQ_WORKER);\n  new_flags |= PF_FORKNOEXEC;\n   p->flags = new_flags;\n}\n\nSYSCALL_DEFINE1(set_tid_address, int __user *, tidptr)\n{\n current->clear_child_tid = tidptr;\n\n  return task_pid_vnr(current);\n}\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n  raw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n    plist_head_init(&p->pi_waiters);\n  p->pi_blocked_on = NULL;\n#endif\n}\n\n#ifdef CONFIG_MM_OWNER\nvoid mm_init_owner(struct mm_struct *mm, struct task_struct *p)\n{\n mm->owner = p;\n}\n#endif /* CONFIG_MM_OWNER */\n\n/*\n * Initialize POSIX timer handling for a single task.\n */\nstatic void posix_cpu_timers_init(struct task_struct *tsk)\n{\n  tsk->cputime_expires.prof_exp = 0;\n    tsk->cputime_expires.virt_exp = 0;\n    tsk->cputime_expires.sched_exp = 0;\n   INIT_LIST_HEAD(&tsk->cpu_timers[0]);\n  INIT_LIST_HEAD(&tsk->cpu_timers[1]);\n  INIT_LIST_HEAD(&tsk->cpu_timers[2]);\n}\n\n/*\n * This creates a new process as a copy of the old one,\n * but does not actually start it yet.\n *\n * It copies the registers, and all the appropriate\n * parts of the process environment (as per the clone\n * flags). The actual kick-off is left to the caller.\n */\nstatic struct task_struct *copy_process(unsigned long clone_flags,\n                    unsigned long stack_start,\n                    struct pt_regs *regs,\n                 unsigned long stack_size,\n                 int __user *child_tidptr,\n                 struct pid *pid,\n                  int trace)\n{\n int retval;\n   struct task_struct *p;\n    int cgroup_callbacks_done = 0;\n\n  if ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n     return ERR_PTR(-EINVAL);\n\n    /*\n     * Thread groups must share signals as well, and detached threads\n  * can only be started up within the thread group.\n     */\n   if ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))\n       return ERR_PTR(-EINVAL);\n\n    /*\n     * Shared signal handlers imply shared VM. By way of the above,\n    * thread groups also imply shared VM. Blocking this case allows\n   * for various simplifications in other code.\n  */\n   if ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))\n       return ERR_PTR(-EINVAL);\n\n    /*\n     * Siblings of global init remain as zombies on exit since they are\n    * not reaped by their parent (swapper). To solve this and to avoid\n    * multi-rooted process trees, prevent global and container-inits\n  * from creating siblings.\n     */\n   if ((clone_flags & CLONE_PARENT) &&\n               current->signal->flags & SIGNAL_UNKILLABLE)\n       return ERR_PTR(-EINVAL);\n\n    retval = security_task_create(clone_flags);\n   if (retval)\n       goto fork_out;\n\n  retval = -ENOMEM;\n p = dup_task_struct(current);\n if (!p)\n       goto fork_out;\n\n  ftrace_graph_init_task(p);\n\n  rt_mutex_init_task(p);\n\n#ifdef CONFIG_PROVE_LOCKING\n DEBUG_LOCKS_WARN_ON(!p->hardirqs_enabled);\n    DEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);\n#endif\n    retval = -EAGAIN;\n if (atomic_read(&p->real_cred->user->processes) >=\n            task_rlimit(p, RLIMIT_NPROC)) {\n       if (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE) &&\n          p->real_cred->user != INIT_USER)\n          goto bad_fork_free;\n   }\n current->flags &= ~PF_NPROC_EXCEEDED;\n\n   retval = copy_creds(p, clone_flags);\n  if (retval < 0)\n       goto bad_fork_free;\n\n /*\n     * If multiple threads are within copy_process(), then this check\n  * triggers too late. This doesn't hurt, the check is only there\n   * to stop root fork bombs.\n    */\n   retval = -EAGAIN;\n if (nr_threads >= max_threads)\n        goto bad_fork_cleanup_count;\n\n    if (!try_module_get(task_thread_info(p)->exec_domain->module))\n        goto bad_fork_cleanup_count;\n\n    p->did_exec = 0;\n  delayacct_tsk_init(p);  /* Must remain after dup_task_struct() */\n copy_flags(clone_flags, p);\n   INIT_LIST_HEAD(&p->children);\n INIT_LIST_HEAD(&p->sibling);\n  rcu_copy_process(p);\n  p->vfork_done = NULL;\n spin_lock_init(&p->alloc_lock);\n\n init_sigpending(&p->pending);\n\n   p->utime = p->stime = p->gtime = 0;\n   p->utimescaled = p->stimescaled = 0;\n#ifndef CONFIG_VIRT_CPU_ACCOUNTING\n  p->prev_utime = p->prev_stime = 0;\n#endif\n#if defined(SPLIT_RSS_COUNTING)\n   memset(&p->rss_stat, 0, sizeof(p->rss_stat));\n#endif\n\n   p->default_timer_slack_ns = current->timer_slack_ns;\n\n    task_io_accounting_init(&p->ioac);\n    acct_clear_integrals(p);\n\n    posix_cpu_timers_init(p);\n\n   do_posix_clock_monotonic_gettime(&p->start_time);\n p->real_start_time = p->start_time;\n   monotonic_to_bootbased(&p->real_start_time);\n  p->io_context = NULL;\n p->audit_context = NULL;\n  if (clone_flags & CLONE_THREAD)\n       threadgroup_change_begin(current);\n    cgroup_fork(p);\n#ifdef CONFIG_NUMA\n   p->mempolicy = mpol_dup(p->mempolicy);\n    if (IS_ERR(p->mempolicy)) {\n       retval = PTR_ERR(p->mempolicy);\n       p->mempolicy = NULL;\n      goto bad_fork_cleanup_cgroup;\n }\n mpol_fix_fork_child_flag(p);\n#endif\n#ifdef CONFIG_CPUSETS\n   p->cpuset_mem_spread_rotor = NUMA_NO_NODE;\n    p->cpuset_slab_spread_rotor = NUMA_NO_NODE;\n   seqcount_init(&p->mems_allowed_seq);\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n    p->irq_events = 0;\n#ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW\n    p->hardirqs_enabled = 1;\n#else\n   p->hardirqs_enabled = 0;\n#endif\n  p->hardirq_enable_ip = 0;\n p->hardirq_enable_event = 0;\n  p->hardirq_disable_ip = _THIS_IP_;\n    p->hardirq_disable_event = 0;\n p->softirqs_enabled = 1;\n  p->softirq_enable_ip = _THIS_IP_;\n p->softirq_enable_event = 0;\n  p->softirq_disable_ip = 0;\n    p->softirq_disable_event = 0;\n p->hardirq_context = 0;\n   p->softirq_context = 0;\n#endif\n#ifdef CONFIG_LOCKDEP\n    p->lockdep_depth = 0; /* no locks held yet */\n p->curr_chain_key = 0;\n    p->lockdep_recursion = 0;\n#endif\n\n#ifdef CONFIG_DEBUG_MUTEXES\n  p->blocked_on = NULL; /* not blocked yet */\n#endif\n#ifdef CONFIG_CGROUP_MEM_RES_CTLR\n    p->memcg_batch.do_batch = 0;\n  p->memcg_batch.memcg = NULL;\n#endif\n\n    /* Perform scheduler related setup. Assign this task to a CPU. */\n sched_fork(p);\n\n  retval = perf_event_init_task(p);\n if (retval)\n       goto bad_fork_cleanup_policy;\n retval = audit_alloc(p);\n  if (retval)\n       goto bad_fork_cleanup_policy;\n /* copy all the process information */\n    retval = copy_semundo(clone_flags, p);\n    if (retval)\n       goto bad_fork_cleanup_audit;\n  retval = copy_files(clone_flags, p);\n  if (retval)\n       goto bad_fork_cleanup_semundo;\n    retval = copy_fs(clone_flags, p);\n if (retval)\n       goto bad_fork_cleanup_files;\n  retval = copy_sighand(clone_flags, p);\n    if (retval)\n       goto bad_fork_cleanup_fs;\n retval = copy_signal(clone_flags, p);\n if (retval)\n       goto bad_fork_cleanup_sighand;\n    retval = copy_mm(clone_flags, p);\n if (retval)\n       goto bad_fork_cleanup_signal;\n retval = copy_namespaces(clone_flags, p);\n if (retval)\n       goto bad_fork_cleanup_mm;\n retval = copy_io(clone_flags, p);\n if (retval)\n       goto bad_fork_cleanup_namespaces;\n retval = copy_thread(clone_flags, stack_start, stack_size, p, regs);\n  if (retval)\n       goto bad_fork_cleanup_io;\n\n   if (pid != &init_struct_pid) {\n        retval = -ENOMEM;\n     pid = alloc_pid(p->nsproxy->pid_ns);\n      if (!pid)\n         goto bad_fork_cleanup_io;\n }\n\n   p->pid = pid_nr(pid);\n p->tgid = p->pid;\n if (clone_flags & CLONE_THREAD)\n       p->tgid = current->tgid;\n\n    p->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? child_tidptr : NULL;\n  /*\n     * Clear TID on mm_release()?\n  */\n   p->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? child_tidptr : NULL;\n#ifdef CONFIG_BLOCK\n p->plug = NULL;\n#endif\n#ifdef CONFIG_FUTEX\n  p->robust_list = NULL;\n#ifdef CONFIG_COMPAT\n  p->compat_robust_list = NULL;\n#endif\n INIT_LIST_HEAD(&p->pi_state_list);\n    p->pi_state_cache = NULL;\n#endif\n /*\n     * sigaltstack should be cleared when sharing the same VM\n  */\n   if ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n       p->sas_ss_sp = p->sas_ss_size = 0;\n\n  /*\n     * Syscall tracing and stepping should be turned off in the\n    * child regardless of CLONE_PTRACE.\n   */\n   user_disable_single_step(p);\n  clear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);\n#ifdef TIF_SYSCALL_EMU\n  clear_tsk_thread_flag(p, TIF_SYSCALL_EMU);\n#endif\n    clear_all_latency_tracing(p);\n\n   /* ok, now we should be set up.. */\n   if (clone_flags & CLONE_THREAD)\n       p->exit_signal = -1;\n  else if (clone_flags & CLONE_PARENT)\n      p->exit_signal = current->group_leader->exit_signal;\n  else\n      p->exit_signal = (clone_flags & CSIGNAL);\n\n   p->pdeath_signal = 0;\n p->exit_state = 0;\n\n  p->nr_dirtied = 0;\n    p->nr_dirtied_pause = 128 >> (PAGE_SHIFT - 10);\n   p->dirty_paused_when = 0;\n\n   /*\n     * Ok, make it visible to the rest of the system.\n  * We dont wake it up yet.\n     */\n   p->group_leader = p;\n  INIT_LIST_HEAD(&p->thread_group);\n\n   /* Now that the task is set up, run cgroup callbacks if\n    * necessary. We need to run them before the task is visible\n   * on the tasklist. */\n    cgroup_fork_callbacks(p);\n cgroup_callbacks_done = 1;\n\n  /* Need tasklist lock for parent etc handling! */\n write_lock_irq(&tasklist_lock);\n\n /* CLONE_PARENT re-uses the old parent */\n if (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {\n      p->real_parent = current->real_parent;\n        p->parent_exec_id = current->parent_exec_id;\n  } else {\n      p->real_parent = current;\n     p->parent_exec_id = current->self_exec_id;\n    }\n\n   spin_lock(&current->sighand->siglock);\n\n  /*\n     * Process group and session signals need to be delivered to just the\n  * parent before the fork or both the parent and the child after the\n   * fork. Restart if a signal comes in before we add the new process to\n     * it's process group.\n     * A fatal signal pending means that current will exit, so the new\n     * thread can't slip out of an OOM kill (or normal SIGKILL).\n  */\n    recalc_sigpending();\n  if (signal_pending(current)) {\n        spin_unlock(&current->sighand->siglock);\n      write_unlock_irq(&tasklist_lock);\n     retval = -ERESTARTNOINTR;\n     goto bad_fork_free_pid;\n   }\n\n   if (clone_flags & CLONE_THREAD) {\n     current->signal->nr_threads++;\n        atomic_inc(&current->signal->live);\n       atomic_inc(&current->signal->sigcnt);\n     p->group_leader = current->group_leader;\n      list_add_tail_rcu(&p->thread_group, &p->group_leader->thread_group);\n  }\n\n   if (likely(p->pid)) {\n     ptrace_init_task(p, (clone_flags & CLONE_PTRACE) || trace);\n\n     if (thread_group_leader(p)) {\n         if (is_child_reaper(pid))\n             p->nsproxy->pid_ns->child_reaper = p;\n\n           p->signal->leader_pid = pid;\n          p->signal->tty = tty_kref_get(current->signal->tty);\n          attach_pid(p, PIDTYPE_PGID, task_pgrp(current));\n          attach_pid(p, PIDTYPE_SID, task_session(current));\n            list_add_tail(&p->sibling, &p->real_parent->children);\n            list_add_tail_rcu(&p->tasks, &init_task.tasks);\n           __this_cpu_inc(process_counts);\n       }\n     attach_pid(p, PIDTYPE_PID, pid);\n      nr_threads++;\n }\n\n   total_forks++;\n    spin_unlock(&current->sighand->siglock);\n  write_unlock_irq(&tasklist_lock);\n proc_fork_connector(p);\n   cgroup_post_fork(p);\n  if (clone_flags & CLONE_THREAD)\n       threadgroup_change_end(current);\n  perf_event_fork(p);\n\n trace_task_newtask(p, clone_flags);\n\n return p;\n\nbad_fork_free_pid:\n   if (pid != &init_struct_pid)\n      free_pid(pid);\nbad_fork_cleanup_io:\n  if (p->io_context)\n        exit_io_context(p);\nbad_fork_cleanup_namespaces:\n if (unlikely(clone_flags & CLONE_NEWPID))\n     pid_ns_release_proc(p->nsproxy->pid_ns);\n  exit_task_namespaces(p);\nbad_fork_cleanup_mm:\n    if (p->mm)\n        mmput(p->mm);\nbad_fork_cleanup_signal:\n   if (!(clone_flags & CLONE_THREAD))\n        free_signal_struct(p->signal);\nbad_fork_cleanup_sighand:\n __cleanup_sighand(p->sighand);\nbad_fork_cleanup_fs:\n  exit_fs(p); /* blocking */\nbad_fork_cleanup_files:\n   exit_files(p); /* blocking */\nbad_fork_cleanup_semundo:\n  exit_sem(p);\nbad_fork_cleanup_audit:\n audit_free(p);\nbad_fork_cleanup_policy:\n  perf_event_free_task(p);\n#ifdef CONFIG_NUMA\n  mpol_put(p->mempolicy);\nbad_fork_cleanup_cgroup:\n#endif\n if (clone_flags & CLONE_THREAD)\n       threadgroup_change_end(current);\n  cgroup_exit(p, cgroup_callbacks_done);\n    delayacct_tsk_free(p);\n    module_put(task_thread_info(p)->exec_domain->module);\nbad_fork_cleanup_count:\n    atomic_dec(&p->cred->user->processes);\n    exit_creds(p);\nbad_fork_free:\n    free_task(p);\nfork_out:\n  return ERR_PTR(retval);\n}\n\nnoinline struct pt_regs * __cpuinit __attribute__((weak)) idle_regs(struct pt_regs *regs)\n{\n    memset(regs, 0, sizeof(struct pt_regs));\n  return regs;\n}\n\nstatic inline void init_idle_pids(struct pid_link *links)\n{\n   enum pid_type type;\n\n for (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n        INIT_HLIST_NODE(&links[type].node); /* not really needed */\n       links[type].pid = &init_struct_pid;\n   }\n}\n\nstruct task_struct * __cpuinit fork_idle(int cpu)\n{\n  struct task_struct *task;\n struct pt_regs regs;\n\n    task = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n               &init_struct_pid, 0);\n if (!IS_ERR(task)) {\n      init_idle_pids(task->pids);\n       init_idle(task, cpu);\n }\n\n   return task;\n}\n\n/*\n *  Ok, this is the main fork-routine.\n *\n * It copies the process, and if successful kick-starts\n * it and waits for it to finish using the VM if required.\n */\nlong do_fork(unsigned long clone_flags,\n        unsigned long stack_start,\n        struct pt_regs *regs,\n         unsigned long stack_size,\n         int __user *parent_tidptr,\n        int __user *child_tidptr)\n{\n    struct task_struct *p;\n    int trace = 0;\n    long nr;\n\n    /*\n     * Do some preliminary argument and permissions checking before we\n     * actually start allocating stuff\n     */\n   if (clone_flags & CLONE_NEWUSER) {\n        if (clone_flags & CLONE_THREAD)\n           return -EINVAL;\n       /* hopefully this check will go away when userns support is\n        * complete\n        */\n       if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SETUID) ||\n                !capable(CAP_SETGID))\n         return -EPERM;\n    }\n\n   /*\n     * Determine whether and which event to report to ptracer.  When\n   * called from kernel_thread or CLONE_UNTRACED is explicitly\n   * requested, no event is reported; otherwise, report if the event\n     * for the type of forking is enabled.\n     */\n   if (likely(user_mode(regs)) && !(clone_flags & CLONE_UNTRACED)) {\n     if (clone_flags & CLONE_VFORK)\n            trace = PTRACE_EVENT_VFORK;\n       else if ((clone_flags & CSIGNAL) != SIGCHLD)\n          trace = PTRACE_EVENT_CLONE;\n       else\n          trace = PTRACE_EVENT_FORK;\n\n      if (likely(!ptrace_event_enabled(current, trace)))\n            trace = 0;\n    }\n\n   p = copy_process(clone_flags, stack_start, regs, stack_size,\n           child_tidptr, NULL, trace);\n  /*\n     * Do this prior waking up the new thread - the thread pointer\n     * might get invalid after that point, if the thread exits quickly.\n    */\n   if (!IS_ERR(p)) {\n     struct completion vfork;\n\n        trace_sched_process_fork(current, p);\n\n       nr = task_pid_vnr(p);\n\n       if (clone_flags & CLONE_PARENT_SETTID)\n            put_user(nr, parent_tidptr);\n\n        if (clone_flags & CLONE_VFORK) {\n          p->vfork_done = &vfork;\n           init_completion(&vfork);\n          get_task_struct(p);\n       }\n\n       wake_up_new_task(p);\n\n        /* forking complete and child started to run, tell ptracer */\n     if (unlikely(trace))\n          ptrace_event(trace, nr);\n\n        if (clone_flags & CLONE_VFORK) {\n          if (!wait_for_vfork_done(p, &vfork))\n              ptrace_event(PTRACE_EVENT_VFORK_DONE, nr);\n        }\n } else {\n      nr = PTR_ERR(p);\n  }\n return nr;\n}\n\n#ifndef ARCH_MIN_MMSTRUCT_ALIGN\n#define ARCH_MIN_MMSTRUCT_ALIGN 0\n#endif\n\nstatic void sighand_ctor(void *data)\n{\n    struct sighand_struct *sighand = data;\n\n  spin_lock_init(&sighand->siglock);\n    init_waitqueue_head(&sighand->signalfd_wqh);\n}\n\nvoid __init proc_caches_init(void)\n{\n  sighand_cachep = kmem_cache_create(\"sighand_cache\",\n         sizeof(struct sighand_struct), 0,\n         SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_DESTROY_BY_RCU|\n            SLAB_NOTRACK, sighand_ctor);\n  signal_cachep = kmem_cache_create(\"signal_cache\",\n           sizeof(struct signal_struct), 0,\n          SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n    files_cachep = kmem_cache_create(\"files_cache\",\n         sizeof(struct files_struct), 0,\n           SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n    fs_cachep = kmem_cache_create(\"fs_cache\",\n           sizeof(struct fs_struct), 0,\n          SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n    /*\n     * FIXME! The \"sizeof(struct mm_struct)\" currently includes the\n  * whole struct cpumask for the OFFSTACK case. We could change\n     * this to *only* allocate as much of it as required by the\n    * maximum number of CPU's we can ever have.  The cpumask_allocation\n   * is at the end of the structure, exactly for that reason.\n    */\n   mm_cachep = kmem_cache_create(\"mm_struct\",\n          sizeof(struct mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,\n            SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);\n    vm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC);\n  mmap_init();\n  nsproxy_cache_init();\n}\n\n/*\n * Check constraints on flags passed to the unshare system call.\n */\nstatic int check_unshare_flags(unsigned long unshare_flags)\n{\n if (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|CLONE_SIGHAND|\n                CLONE_VM|CLONE_FILES|CLONE_SYSVSEM|\n               CLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWNET))\n      return -EINVAL;\n   /*\n     * Not implemented, but pretend it works if there is nothing to\n    * unshare. Note that unsharing CLONE_THREAD or CLONE_SIGHAND\n  * needs to unshare vm.\n    */\n   if (unshare_flags & (CLONE_THREAD | CLONE_SIGHAND | CLONE_VM)) {\n      /* FIXME: get_task_mm() increments ->mm_users */\n      if (atomic_read(&current->mm->mm_users) > 1)\n          return -EINVAL;\n   }\n\n   return 0;\n}\n\n/*\n * Unshare the filesystem structure if it is being shared\n */\nstatic int unshare_fs(unsigned long unshare_flags, struct fs_struct **new_fsp)\n{\n struct fs_struct *fs = current->fs;\n\n if (!(unshare_flags & CLONE_FS) || !fs)\n       return 0;\n\n   /* don't need lock here; in the worst case we'll do useless copy */\n   if (fs->users == 1)\n       return 0;\n\n   *new_fsp = copy_fs_struct(fs);\n    if (!*new_fsp)\n        return -ENOMEM;\n\n return 0;\n}\n\n/*\n * Unshare file descriptor table if it is being shared\n */\nstatic int unshare_fd(unsigned long unshare_flags, struct files_struct **new_fdp)\n{\n struct files_struct *fd = current->files;\n int error = 0;\n\n  if ((unshare_flags & CLONE_FILES) &&\n      (fd && atomic_read(&fd->count) > 1)) {\n        *new_fdp = dup_fd(fd, &error);\n        if (!*new_fdp)\n            return error;\n }\n\n   return 0;\n}\n\n/*\n * unshare allows a process to 'unshare' part of the process\n * context which was originally shared using clone.  copy_*\n * functions used by do_fork() cannot be used here directly\n * because they modify an inactive task_struct that is being\n * constructed. Here we are modifying the current, active,\n * task_struct.\n */\nSYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)\n{\n struct fs_struct *fs, *new_fs = NULL;\n struct files_struct *fd, *new_fd = NULL;\n  struct nsproxy *new_nsproxy = NULL;\n   int do_sysvsem = 0;\n   int err;\n\n    err = check_unshare_flags(unshare_flags);\n if (err)\n      goto bad_unshare_out;\n\n   /*\n     * If unsharing namespace, must also unshare filesystem information.\n   */\n   if (unshare_flags & CLONE_NEWNS)\n      unshare_flags |= CLONE_FS;\n    /*\n     * CLONE_NEWIPC must also detach from the undolist: after switching\n    * to a new ipc namespace, the semaphore arrays from the old\n   * namespace are unreachable.\n  */\n   if (unshare_flags & (CLONE_NEWIPC|CLONE_SYSVSEM))\n     do_sysvsem = 1;\n   err = unshare_fs(unshare_flags, &new_fs);\n if (err)\n      goto bad_unshare_out;\n err = unshare_fd(unshare_flags, &new_fd);\n if (err)\n      goto bad_unshare_cleanup_fs;\n  err = unshare_nsproxy_namespaces(unshare_flags, &new_nsproxy, new_fs);\n    if (err)\n      goto bad_unshare_cleanup_fd;\n\n    if (new_fs || new_fd || do_sysvsem || new_nsproxy) {\n      if (do_sysvsem) {\n         /*\n             * CLONE_SYSVSEM is equivalent to sys_exit().\n          */\n           exit_sem(current);\n        }\n\n       if (new_nsproxy) {\n            switch_task_namespaces(current, new_nsproxy);\n         new_nsproxy = NULL;\n       }\n\n       task_lock(current);\n\n     if (new_fs) {\n         fs = current->fs;\n         spin_lock(&fs->lock);\n         current->fs = new_fs;\n         if (--fs->users)\n              new_fs = NULL;\n            else\n              new_fs = fs;\n          spin_unlock(&fs->lock);\n       }\n\n       if (new_fd) {\n         fd = current->files;\n          current->files = new_fd;\n          new_fd = fd;\n      }\n\n       task_unlock(current);\n }\n\n   if (new_nsproxy)\n      put_nsproxy(new_nsproxy);\n\nbad_unshare_cleanup_fd:\n  if (new_fd)\n       put_files_struct(new_fd);\n\nbad_unshare_cleanup_fs:\n  if (new_fs)\n       free_fs_struct(new_fs);\n\nbad_unshare_out:\n   return err;\n}\n\n/*\n *    Helper to unshare the files of the current task.\n *    We don't want to expose copy_files internals to\n * the exec layer of the kernel.\n */\n\nint unshare_files(struct files_struct **displaced)\n{\n   struct task_struct *task = current;\n   struct files_struct *copy = NULL;\n int error;\n\n  error = unshare_fd(CLONE_FILES, &copy);\n   if (error || !copy) {\n     *displaced = NULL;\n        return error;\n }\n *displaced = task->files;\n task_lock(task);\n  task->files = copy;\n   task_unlock(task);\n    return 0;\n}\n"
}